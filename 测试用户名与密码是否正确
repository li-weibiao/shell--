#!/bin/bash
#用户名为 tom 并且密码为 123456,则提示登录成功,否则提示登录失败

read -p "请输入用户名:" user
read -p "请输入密码:" pass
if [ "$user" == 'tom' -a "$pass" == '123456' ];then
       echo "Login successful"
else
      echo "Login Failed"
fi

#########################################
eg:
&&和-a都表示“与”判断，比如：

if [ ! $1 == 1 ] && [ $2 ==2 ] ; then

echo “OK!”

fi

    1
    2
    3
    4
    5

和

if [ ! $1 == 1 -a $2 ==2 ] ; then

echo “OK!”

fi

    1
    2
    3
    4
    5

都是判断$1 != 1 并且$2 = 2时就OK！一般情况下两种用法都可以，但是有区别：

&&表示前者判断成功，才会执行后者。而-a则两者都会执行再去判断。

[ ! $1 == 1 ] 有两种情况：$1存在且不是1的其它数字[0 2-9]、$1为空。如果用[ ! $1 == 1 ] && [ $2 ==2 ] ，$1为空时就不会执行 [ $2 ==2 ] ，所以无法执行。如果用[ ! $1 == 1 -a $2 ==2 ] ，则完全无问题。

||和-o都可用来表示“或”判断。|| 和-o 却和“&&和-a”不太一样，||表示前者判断成功就执行后者判断，[ ! $1 == 1 ] || [ $2 ==2 ]，$1不论是空还是[0 2-9]，都表示判断成功（即不等于1），都会执行后者[ $2 ==2 ] ,所以就没有前面&&的担忧，和[ ! $1 == 1 -o $2 ==2 ]是一样的。

另外，和前面所说，&&表示前面执行成功则执行后面的，||表示前面执行不成功则执行后面的，所以就有这种用法：

打电话给MM如果接通 && 约她 ------前面成功，就有后续

打电话给MM如果接通 || 打给另一个 ------这个不用说啦

然后又有这种用法：

打电话给MM如果接通 && 约她 && 请去吃饭 && 去开房 && 发朋友圈 （表示以前一步骤为成功条件逐步执行所有命令）

打电话给MM如果接通 && 约她 && 请去吃饭 && 去开房 || 打给另一个 （开房这个步骤不成功，就执行约另一个，设定的前面步骤不成功，就换另一个操作)

实际用法：

HTB=(ucigetcowbqos.@cowbqos[0].HTB2>/dev/null) || HTB=1这个表示，前面取值如果存在，就使用取得的值，如果不存在（执行错误），就赋予1值。

如果使用 HTB=(uci get cowbqos.@cowbqos[0].HTB 2>/dev/null) && HTB=1 表示前面取值存在，就赋予1，如果不存在，就没有然后了。如果还想要然后，可以这样：

HTB=(ucigetcowbqos.@cowbqos[0].HTB2>/dev/null) && HTB=1 || HTB=0，表示如果取值成功，就赋予1（事实上不叫赋予，是替换），不成功，就赋予0

但是不能这样用：HTB=(ucigetcowbqos.@cowbqos[0].HTB 2>/dev/null) || HTB=1 && CCC=1

原本你是希望取值失败就HTB=1 && CCC=1同时执行的，但是事与愿违，不论取值是成功或者失败，CCC=1都会执行，等同于：HTB=(ucigetcowbqos.@cowbqos[0].HTB 2>/dev/null) || HTB=1 ; CCC=1。

下面又有个问题：

打电话给MM如果接通 && 约她 && 请去吃饭 && 去开房 && 发朋友圈

打电话给MM如果接通 ; 约她 ; 请去吃饭 ; 去开房 ; 发朋友圈

两者有区别吗？如果事情顺利的话，两者得到的结果一样。但是不顺利却完全不一样。

前者任意一个步骤不顺利，就在该步骤终结，后续不会再做。

后者完全不一样，任何步骤不顺利，所有步骤都会做完（毕竟那些事情一个人也可以做）。即后者没有因果判断，只有前后顺序的区别。
