#!/bin/bash
#MAC 地址由 16 进制组成,如 AA:BB:CC:DD:EE:FF
#[0-9a-fA-F]{2}表示一段十六进制数值,{5}表示连续出现 5 组前置:的十六进制
egrep "[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}" $1
########################################################
eg:
# 关于MAC地址
MAC地址，也就是网卡MAC码。网卡MAC码是由IEEE的注册管理机构固定分配的,因此每一个主机会有一个MAC地址，具有全球唯一性。

需求分析
因为业务需求需要用验证MAC地址是否合法，因而想到用正则进行匹配。

原正则表达式为：
([A-Fa-f0-9]{2}-){5}[A-Fa-f0-9]{2}

因为考虑到MAC地址一般有两种格式，使用-连接或是:连接，于是我稍作改动，改动结果如下:
/(([a-f0-9]{2}:)|([a-f0-9]{2}-)){5}[a-f0-9]{2}/gi
以上正则表达式就是最终版的MAC地址验证表达式，如果不清楚具体原理可以接着往下看。

拆解分析
1. [a-f0-9]
匹配a到f或0到9中的任意一位字符。
匹配的结果例如2或d。

2. [a-f0-9]{2}
匹配连续两位的括号中任意字符。
匹配的结果例如d2或ac。

3. [a-f0-9]{2}:
连续两位的括号中任意字符再拼接一个:(冒号)。
匹配的结果例如b2:或23:

4. ([a-f0-9]{2}:)|([a-f0-9]{2}-)
在第三步的基础上可以将冒号替换为横杠。
匹配的结果例如f3:或79-

5. (([a-f0-9]{2}:)|([a-f0-9]{2}-)){5}
将第四步的结果重复5次。
匹配的结果例如00-01-6C-06-A6-或00:01:6C:06:A6:

6. (([a-f0-9]{2}:)|([a-f0-9]{2}-)){5}[a-f0-9]{2}
在第五步的结果上再拼接两个[A-F0-Z]范围内的两个字符
匹配的结果例如00-01-6C-06-A6-29或00:01:6C:06:A6:29

7. 设置大小写不敏感与全局匹配
在正则最后加上/ig。
完整的正则表达式也就是：
/(([a-f0-9]{2}:)|([a-f0-9]{2}-)){5}[a-f0-9]{2}/gi

END
